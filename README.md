# KernelFit

C++ classes for single and multidimensional non-parametric Gaussian kernel
regression. These objects allow for the fitting of smooth profiles through
noisy data. The functions that solve for the profile are 
*embarrassingly parallel* and use OpenMP to gain large speedups.

**License:** 
[GNU General Public License, version 3](https://www.gnu.org/copyleft/gpl.html). 
See the LICENSE file.

**Dependencies:**
STL and OpenMP

The header and source file, *KernelFit.hh* and *KernelFit.cc*, respectively
are located in the *Source* directory. The user should simply put the header
file with the other header files for their project and compile, link the
source file with their other source files. The *Makefile* included with this
repository compiles and runs the test programs *TestKernelFit1D.cc* and
*TestKernelFit2D.cc* in the *Test* directory. The figures included below 
represent the results of those programs.

**Example:**
After included the code in your project, you can use them similar to the
below snippet:

```C++
KernelFit1D<double> kernel_fit(x, y, bandwidth);
std::vector<double> profile = kernel_fit.Solve(new_x);
```


![example](Figures/KernelFit1D.png "Results of KernelFit1D")

**Figure** **1:** The above figure was plotting using Python and showcases the 
results of the TestKernelFit1D.cc program. A noisy sinc function was produced 
with both *red* and *white* noise. The blue dashed line demonstrates the smooth 
profile fit through the data. The red dashed line shows the analytical function.

![example](Figures/KernelFit2D.png "Results of KernelFit1D")

**Figure** **2:** The above figure was plotting using Python and showcases the 
results of the TestKernelFit2D.cc program. Just as in the example in Figure 1,
A sinc function was used here as well but radially. The brown-red scatter points
are the raw data produced. The *terrain* colored mesh grid showcases the 
smooth surface profile generated by the KernelFit2D algorithm.
